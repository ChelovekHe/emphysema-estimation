#include <iostream>

#include "Eigen/Dense"
#include "LLPCostFunction.h"


int main() {
  typedef double ElementType;
  typedef Eigen::Matrix< ElementType,
			 Eigen::Dynamic,
			 Eigen::Dynamic,
			 Eigen::RowMajor > MatrixType;
  typedef Eigen::Matrix< ElementType, Eigen::Dynamic, 1 > VectorType;
  typedef LLPCostFunction< VectorType, MatrixType > CostFunctorType;
  
  VectorType x(20);
  x <<
    0,
    0.128254,
    0.127521,
    0,
    0.0279122,
    0,
    0,
    0.0305314,
    0.0113416,
    0,
    0.00471196,
    0.569278,
    0.098981,
    0,
    0.460925,
    0.141274,
    0,
    0.0398201,
    0,
    0.0507653;



   VectorType p(20);
   p << 0.1075,  0,  0,  0,  0,  0,  0,  0.09,  0.0975,  0.104583333333333,  0.23,  0,
     0.119166666666667,  0,  0,  0.224166666666667,  0.2875,  0.144166666666667,
     0.144166666666667,  0;
  
  MatrixType C(20,20);
  C <<
0.02,    0,    0,    0,    0,  0.2, 0.02, 0.22,    0, 0.06,    0,    0, 0.22,    0, 0.02, 0.14,    0,    0, 0.02, 0.08,
   0, 0.06, 0.04,  0.2,    0,    0,    0,    0,  0.1,    0, 0.04, 0.08,    0, 0.24, 0.04,    0, 0.06,  0.1, 0.04,    0,
0.12,    0, 0.02, 0.06, 0.02,    0, 0.14, 0.12, 0.02, 0.06, 0.06,    0, 0.02, 0.02, 0.02, 0.08, 0.06,    0,  0.1, 0.08,
0.06, 0.08, 0.12,    0,  0.1,    0, 0.12,    0,  0.1,    0, 0.02,    0,    0, 0.14, 0.04,    0,    0, 0.12,  0.1,    0,
0.14,    0, 0.02,    0,    0, 0.16, 0.06,  0.1, 0.02, 0.16,    0,    0, 0.04, 0.02,    0, 0.16, 0.02,    0,    0,  0.1,
0.14, 0.02, 0.04, 0.02, 0.06,    0, 0.12, 0.02,  0.1, 0.02,    0,    0,    0, 0.02,    0,    0, 0.14, 0.22, 0.08,    0,
0.12,    0,    0,    0, 0.04, 0.06, 0.16, 0.04, 0.06, 0.08, 0.02,    0, 0.06,    0, 0.02,  0.1,  0.1, 0.06, 0.06, 0.02,
0.06, 0.06, 0.04, 0.08, 0.04,    0, 0.06,    0, 0.06, 0.02, 0.08, 0.02, 0.02, 0.12,  0.1, 0.02, 0.08,  0.1, 0.04,    0,
   0, 0.08, 0.12, 0.14,    0,    0,    0,    0, 0.06,    0, 0.22, 0.14, 0.02, 0.08,  0.1,    0,    0, 0.02, 0.02,    0,
   0, 0.02, 0.12,  0.3,    0,    0,    0,    0, 0.02,    0, 0.12,  0.2,    0, 0.18,    0,    0,    0, 0.04,    0,    0,
   0, 0.08, 0.12, 0.06,    0,    0,    0,    0,  0.1,    0, 0.16, 0.16,    0, 0.18, 0.08,    0, 0.02, 0.02, 0.02,    0,
0.04,    0, 0.02,    0, 0.12, 0.14, 0.04, 0.14, 0.02, 0.08,    0,    0,  0.1, 0.02, 0.02, 0.08, 0.06,    0, 0.02,  0.1,
0.16,    0, 0.04,    0, 0.04,    0, 0.14, 0.02, 0.08, 0.14,    0,    0, 0.02, 0.06, 0.04, 0.08, 0.04, 0.02, 0.02,  0.1,
0.04, 0.02,    0, 0.02,  0.1, 0.02,  0.1, 0.04, 0.04,  0.1, 0.02,    0, 0.04, 0.04, 0.02, 0.08,  0.1, 0.04,  0.1, 0.08,
0.06, 0.04, 0.08, 0.06, 0.02, 0.02, 0.04, 0.04, 0.06, 0.04, 0.08, 0.02, 0.04, 0.12, 0.04, 0.02, 0.06, 0.04, 0.04, 0.08,
0.06, 0.06,  0.1, 0.06, 0.14,    0, 0.06,    0, 0.02, 0.02, 0.04,  0.1, 0.02,  0.1, 0.04, 0.06, 0.06, 0.06,    0,    0,
   0,  0.1, 0.08, 0.02, 0.04, 0.06,    0, 0.02, 0.06,    0,  0.1, 0.14, 0.02, 0.06, 0.12,    0, 0.08,    0,    0,  0.1,
0.04, 0.04, 0.26, 0.12,    0,    0, 0.04,    0, 0.12,    0, 0.04, 0.04,    0,  0.1,  0.1,    0,    0, 0.06, 0.04,    0,
0.02, 0.12,  0.1, 0.08, 0.02,    0, 0.02, 0.02, 0.14,    0, 0.02, 0.06,    0, 0.06, 0.06,    0, 0.06, 0.14, 0.08,    0,
0.12,    0,    0,    0,    0,  0.1, 0.08,  0.1,    0, 0.38,    0,    0, 0.06,    0,    0, 0.12, 0.02,    0,    0, 0.02;


  double* xs = x.data();

  VectorType residuals(p.size() + 1);
  
  double lambda = std::sqrt(static_cast<double>(p.size()));
  
  CostFunctorType cost(p, C, lambda);

  cost.Evaluate( &xs, residuals.data(), NULL );
  double res = 0.5*residuals.squaredNorm();
  

  double t  = lambda * (p - C*x).sum();  
  double eigenRes = 0.5*((p - C*x).squaredNorm() + t*t);
  
  std::cout << "res " << res << std::endl
    	    << "Eigen res " << eigenRes << std::endl
	    << "residual[N] = " << residuals(p.size()) << std::endl
	    << "eigenResisual[N] = " << t << std::endl
	    << "C*x " << std::endl << C*x << std::endl;
  
  
  return 0;
}
